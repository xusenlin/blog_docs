```json
{
  "date": "2020.12.10 22:00",
  "tags": ["正则"]
}
```

在平时的工作中，我们很多地方都会使用到正则，但是实际使用频率并没有那么高，因此很多时候都是去网上查一下修改修改就用了，但是过一段时间就会忘记，每次使用都得回忆理解一些元字符，其实还是比较浪费时间的，正则作为一种生命周期很长的技术，我觉得可以花一些时间去梳理一下，方便必要时候查询。


# 正则可视化工具
- https://regex101.com/ 支持各种语言的在线正则
- http://wangwl.net/  在线验证工具
- https://regexr.com/ 在线验证工具
- https://regexper.com/ 正则铁路图


# 元字符

元字符就是指那些在正则表达式中具有特殊意义的专用字符,比如```\d```。而普通字符表示的还是原来的意思，比如```d```匹配的就是文本里面的字符d。元字符是正则里面非常重要同时又是难以记忆的东西，我们对他分类理解。

辅助记忆
d 是 digit 数字
w 是 word 单词
s 是 space 空白


- 特殊字符（基础元字符）
  - ```.``` 任意字符，除换行符外
  - ```\d``` 任意数字，```\D``` 任意非数字
  - ```\w``` 任意字母数字下划线，```\W``` 任意非字母数字下划线
  - ```\s``` 任意空白符，```\S```任意非空白符。
- 空白符
  - ```\r``` 回车符
  - ```\n``` 换行符
  - ```\f``` 换页符
  - ```\t``` 制表符
  - ```\v``` 垂直制表符
  - ```\s``` 任意空白符
- 量词  （基础元字符匹配的是单个字符，如\d匹配出现过一次的数字，能匹配到多个）
  - ```*``` 0到多次
  - ```+``` 1到多次
  - ```?``` 0到1次
  - ```{m}``` 出现m次
  - ```{m,}``` 出现至少m次
  - ```{m,n}``` 出现m到n次
- 范围
  - ```|``` 或，a|b 匹配a或者b ,(多分支选择都是左边的优先)
  - ```[abcdefg]``` 多选一，括号中任意一个元素
  - ```[a-z]``` 匹配a到z之间的任意一个元素
  - ```[^abcdefg]```  取反，不能是括号中的任意一个元素 ,如[^a-z|A-Z]不能是大小写字母
- 断言 （Assertions） 边界限定 （其他的正则只是匹配文本内容本身，而断言不仅要求文本内容本身的匹配还要求它出现的位置）
  - 单词边界 使用``` \b ``` 来限定单词边界，例如 ``` word\b  ``` 只能匹配单词word,words就不行
  - 行的开始/结束  ，在一行文本开头或结尾，就可以使用 ^ 和 $ 来进行位置界定。
  - 环视，即瞻前顾后，找准定位。``` (?<=Y) ``` 左边是Y，``` (?<!Y)```  左边不是Y，```  (?=Y)``` 右边是Y，``` (?!Y) ``` 右边不是Y。需要注意的是向左看的时候需要放在表达式左边，向右看的时候需要放在表达式右边。

提示：
1. 不同的系统在每行文本结束位置默认的“换行”会有区别，在 Windows 里是 \r\n，在 Linux 和 MacOS 中是 \n。
2. 中括号[]代表多选一，可以表示里面的任意单个字符，所有不需要管道符号“|”。另外，中括号中，我们还可以用中划线表示范围
3. 字符组和多选结构，[]是字符组，本身带有多选一属性，而多选结构可以用```(ab|cd)```表示


示例：
```(https?|ftp):\/\/``` http://或者https://或者ftp://，问号代表s有或者无
```1[3-9]\d{9}``` 匹配11位手机号，1开头紧接着3到9中的一个数，然后接着9个数字


# 量词的贪婪、非贪婪、独占模式


有如下字符串```aaabb```在正则全局(global)匹配模式下我们可以看到正则```a+```出现一次匹配，匹配上了字符串```aaabb```其中的aaa, ```+```这个正则量词元字符表示的是1到多次，也可以用```{1,}```代替，但是我们仔细理解的话，我们会发现如果单独匹配每一个a也满足```+```这个描述，如果那样的话就应该是匹配是三次，每次分别是a啊，为什么只匹配一次？？为什么要按最长的三个a来匹配？？？注意了，这里的最长其实就是所谓的贪婪模式，在正则中，所有的量词默认都是贪婪模式，而非贪婪模式会尽可能短地去匹配。

- 贪婪：尽可能多地去匹配。
- 非贪婪：尽可能短地去匹配。

再来看一个例子，加深理解。还是字符串```aaabb```，有正则```a*```，默认贪婪模式会匹配5次，这5次分别如下：

1. 0-3	aaa
2. 3-3	         //这里匹配到了空的字符串
3. 4-4		       //这里匹配到了空的字符串
4. 5-5	         //这里匹配到了空的字符串
5. 6-6		       //这里匹配到了空的字符串

量词```*``` 相当于```{0,}```,可匹配零次。其实如果是非贪婪模式的话，那是不是都会匹配0次了呢？

### 在量词后面加上英文的问号 ```?``` 就会开启非贪婪匹配（Lazy）模式。

正则```a*?```匹配如下：

1. 0-0	
2. 1-1		        
3. 2-2		      
4. 3-3	       
5. 4-4	
6. 5-5
7. 6-6	

全部匹配到了空的字符串，总共匹配7次。正则```a{1,3}```默认匹配一次，```a{1,3}?```会匹配三次。


又例如：


有html ```<div></div>```,正则```</?.*>```匹配一次，正则```</?.*?>```(非贪婪)匹配两次。

![20-12-11-re](./images/20-12-11-re.png)

涂伟忠老师的图，贪婪和非贪婪模式的区别。

### 独占模式

这个模式很少用，像GOLANG就不支持，独占模式是用来避免向前回溯的，一般是在量词前面添加一个 ```+```号，如```a{1,3}+ab```,

在正常的贪婪模式下，如果用 ```xy{1,3}z``` 去匹配 xyyz 字符串，y{1,3} 会尽量匹配字符串y,因此会向前匹配到位置3，接着字符串中后面是个 z 就会导致匹配不上，这时候正则就会向前回溯。

独占模式和贪婪模式很像，独占模式会尽可能多地去匹配，如果匹配失败就结束，不会进行回溯。

如果用 ```a{1,3}+ab``` 去匹配 aaab 字符串，```a{1,3}+``` 使用贪婪模式会把前面三个 a 都用掉，并且不会回溯，这样字符串中内容只剩下 b 了，导致正则中加号后面的 a 匹配不到符合要求的内容，匹配失败。

如果要深刻理解独占模式的话可能需要对正则的状态机有所了解。

# 小括号（Capture捕获）和分组引用

即添加小括号```()```,在正则中如果添加小括号有两个意义，分别是：

- 当我们需要把一部分元字符看作一个整体的时候
- 当我们需要保存一个子组(子表达式)用来引用时

1. 先来看当我们需要把一部分元字符看作一个整体的时候，需要添加```(?:)```,例如

```\d{15}(?:\d{3})? ```表示匹配15个数字后面的3个数字可有可无,如果我们不用小括号来包含```\d{3}```的话，正则就是```\d{15}\d{3}? ```表达的意思就变成了`匹配15个数字紧跟着使用非贪婪模式匹配3个数字，这里不加?:也是可以的，``` \d{15}(\d{3})? ```  也有相同的意义，只不过不加?:的小括号括起来的部分“子表达式”会被保存成一个子组，所以我们这里只是把一部分元字符看作一个整体，不需要子组功能的时候可以添加?:可以提高正则的性能。

>在小括号里面添加?:表示不保存子组，括号只用于归组，把某个部分当成“单个元素”，不分配编号，后面不会再进行这部分的引用。注意，在断言环视的小括号却没有这个规则。

2. 小括号的第二个功能，保存子组（子表达式）并可以引用和替换，并且每个子组都有自己的编号，它们分别从左到右编号依次递增。

例如正则表达式```(ab)(c)\1```有两个子组，它们分别是编号为1的子组ab,和编号为2的子组c。然后后面的\1表示引用子组编号为1的表达式，那么这个正则展开就是```abcab```，或者理解成```(ab)(c)(ab)```也可以，不过在这里括号可以去掉。

通过上面的例子，我们知道使用小括号保存子组可以在利用，使用小括号加?:不保存子组，不能再次利用，仅仅只是把部分表达式看着一个整体。

注意，golang 官方的正则库是不支持子组引用的。并且在实际替换的时候每种语言还有一些细微的差别，比如js在查找匹配的时候引用使用\1,但是替换时用$1来指定要替换的子组。

```javascript
name = "abcabdefg";
console.log(/(ab)(c)\1/.test(name))
name.replace(/(ab)(c)\1/,"$2$1");
//输出：
//true
//"cabdefg"  $2$1将查找过程中的子组互换位置替换
name = "abcabdefg";
name.replace(/(ab)(c)\1/,"$2-$1");
//输出 "c-abdefg"
```



再来看看括号嵌套的情况下编号是怎样的。

![regular-group.png](./images/regular-group.png)

可以看到，简单场景下我们直接使用这种默认的子组编号没啥问题，但是复杂的情况下是不方便使用的，并且修改了括号位置得重新梳理子组编号，既然是默认的方式，那说明还有其他方式，是的，我们不仅可以使用默认的编号也可以给子组命名。命名分组的格式为(?P<分组名>正则)，但是好像子组命名和引用每种语言都是不一样的，平时候不太建议使用。

例如js的子组命名和引用是``` (?<myname>ab)(c)\k<myname>```，php的则是```  (?P<myname>ab)(c)(?P=myname)```。

JS例子：

```javascript
name = "abcabdefg";
console.log(/(?<myname>ab)(?<myname2>c)\k<myname>/.test(name))
name.replace(/(?<myname>ab)(?<myname2>c)\k<myname>/,"$<myname2>$<myname>");
//输出
//true
//"cabdefg"
//没错，js是使用(?<分组名>正则) 来命名子组的
//再来看看使用场景
const re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const {groups: {day,month, year}} = re.exec('1999-12-31');
```

对此，go官方正则库也是不支持的，舍去一些不常用的正则以提高性能？？？

在来一个例子加深理解

```javascript
let s = "the little cat cat is in the hat hat hat, we like it."
//需要将上面重复的单词替换为一个 
s.replace( =/(\w+)(\s\1)+/g,"$1")
// 更严谨一点添加断言单词边界 =>  (\b\w+)(\s+\1\b)+
```



# 常用匹配模式

- 不区分大小写模式（Case-Insensitive）
- 单行匹配模式（Single Line）== 点号通配模式（Dot All）
- 多行匹配模式（Multiline）
- 注释模式（Comment）

> 开启模式的方法可以在正则后面添加关键字，也可以通过在正则前面使用(? 模式标识) 的方式来表示



1. 之前我们经常在正则最后添加一个小写字母i来表示不区分大小写，例如```/cat/i```，这样就能表示整个正则不不区分大小写，他们能匹配cat、Cat、CAt、CAT，除了这种方式我们也可以使用```  (?i)cat ``` ，就是在这正则前面添加 ```  (?i)``` ,还有一种情况，那就是我只希望匹配cat或者Cat,即只有第一个C才忽略大小写，通过前面的学习我们知道可以使用 ```  c|Cat```,那么如何改变其中一个子表达式的模式呢？我们可以通过 ```  ((?i)c)at``` ,为了提高性能，我们不需要子组则可以使用 ```  (?:(?i)c)at```。
2. 单行匹配模式我们记为点号通配模式，可以使用 ```/.*/s```或者```  (?s).* ```来开启此模式，此模式表示的是我们的元字符```.```开启 任意字符包括除换行符，即让```.``` 真正意义上的匹配"任意"。
3. 多行匹配模式是针对 ```^``` 和 ```$```符号的，我们知道 ```^```匹配整个文本的开头，```$``` 匹配整个文本的结尾。如果开启此模式的话就不是整个文本了，而是每一行。例如```  (?m)^cat|sf$``` 匹配每一行文本的cat和sf，但是必须要求他们是cat开头或者是sf结尾。
4. 注释模式（Comment）即在正则当中添加注释。例如```  (\w+)(?#word) \1(?#word repeat again)``` ,貌似go官方库也不支持。😂

> 注意，js 是后面才支持使用(? 模式标识) 来开启模式，因此某些在线工具可能无法使用。



